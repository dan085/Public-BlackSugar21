rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- LIKES ---
    // Un usuario solo puede leer/escribir sus propios likes
    match /likes/{likeId} {
      allow read, write: if request.auth != null &&
        (likeId.split('_')[0] == request.auth.uid || likeId.split('_')[1] == request.auth.uid);
    }

    // --- MATCHES ---
    // Solo los usuarios involucrados pueden leer el match
    match /matches/{matchId} {
      allow read: if request.auth != null &&
   		 request.auth.uid in resource.data.usersMatched;

      // Permitir crear match si el usuario autenticado está en usersMatched
  		allow create: if request.auth != null &&
            request.auth.uid in request.resource.data.usersMatched;
      
      // Permitir actualizar match (para lastMessageTime, etc.)
      allow update: if request.auth != null &&
            request.auth.uid in resource.data.usersMatched;
      
      // No permitir eliminar
      allow delete: if false;
      
      // Subcolección de MESSAGES dentro de cada match
      match /messages/{messageId} {
        // Los participantes del match pueden leer mensajes
        allow read: if request.auth != null &&
              request.auth.uid in get(/databases/$(database)/documents/matches/$(matchId)).data.usersMatched;
        
        // Helper function: obtener userType ORIGINAL del remitente (en el momento del match)
        function getSenderTypeAtMatch() {
          let matchData = get(/databases/$(database)/documents/matches/$(matchId)).data;
          return matchData.keys().hasAny(['userTypesAtMatch']) 
            ? matchData.userTypesAtMatch[request.auth.uid]
            : get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType;
        }
        
        // Helper function: verificar si el match tiene messageCount > 0
        function hasExistingMessages() {
          let matchData = get(/databases/$(database)/documents/matches/$(matchId)).data;
          // Si messageCount no existe O es 0, retornar false
          // Si existe y es > 0, retornar true
          return matchData.keys().hasAny(['messageCount']) && matchData.messageCount > 0;
        }
        
        // Regla de creación de mensajes
        allow create: if request.auth != null &&
              // El usuario debe ser el remitente
              request.auth.uid == request.resource.data.senderId &&
              // El usuario debe ser participante del match
              request.auth.uid in get(/databases/$(database)/documents/matches/$(matchId)).data.usersMatched &&
              // VALIDACIÓN PRIMER MENSAJE: Solo usuarios que eran SUGAR_DADDY/MOMMY al hacer match pueden iniciar
              (
                // Si ya hay mensajes (messageCount > 0), cualquiera puede enviar
                hasExistingMessages() ||
                // Si ES el primer mensaje, verificar tipo ORIGINAL (al momento del match)
                getSenderTypeAtMatch() == 'SUGAR_DADDY' ||
                getSenderTypeAtMatch() == 'SUGAR_MOMMY' ||
                // FALLBACK: Si no hay userTypesAtMatch, verificar tipo actual (compatibilidad con matches viejos)
                (!get(/databases/$(database)/documents/matches/$(matchId)).data.keys().hasAny(['userTypesAtMatch']) &&
                 (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType == 'SUGAR_DADDY' ||
                  get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType == 'SUGAR_MOMMY'))
              );
        
        // No permitir actualizar o eliminar mensajes
        allow update, delete: if false;
      }
    }

    // --- USERS ---
    match /users/{userId} {
      // Cualquier usuario autenticado puede leer perfiles (incluso si App Check falla en desarrollo)
      allow read: if request.auth != null;

      // Solo el propietario puede crear/actualizar su perfil
      allow create, update: if request.auth != null && 
        request.auth.uid == userId &&
        // Validar que latitude esté en rango válido (-90 a 90)
        (!request.resource.data.keys().hasAny(['latitude']) || 
         (request.resource.data.latitude >= -90 && request.resource.data.latitude <= 90)) &&
        // Validar que longitude esté en rango válido (-180 a 180)
        (!request.resource.data.keys().hasAny(['longitude']) || 
         (request.resource.data.longitude >= -180 && request.resource.data.longitude <= 180)) &&
        // Validar que maxDistance sea un valor positivo razonable (1 a 500 km)
        (!request.resource.data.keys().hasAny(['maxDistance']) || 
         (request.resource.data.maxDistance >= 1 && request.resource.data.maxDistance <= 500));
      
      // Subcolección LIKED: lectura pública (para verificar matches), escritura solo propietario
      match /liked/{likedUserId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == userId;
      }
      
      // Subcolección PASSED: solo propietario
      match /passed/{passedUserId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // Subcolección SWIPES: solo propietario (para cooldown de perfiles)
      match /swipes/{swipedUserId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // Subcolección SUPERLIKED: lectura pública (para mostrar super likes recibidos), escritura solo propietario
      match /superLiked/{superLikedUserId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == userId;
      }
      
      // Subcolección COMPATIBILITY_SCORES: solo propietario puede leer
      match /compatibility_scores/{scoreId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        // Solo Cloud Functions pueden escribir scores
        allow write: if request.auth == null;
      }
    }

    // --- MESSAGES ---
    match /messages/{chatId} {
      // Solo los participantes del chat pueden leer mensajes
      allow read: if request.auth != null &&
        (request.auth.uid == resource.data.senderId ||
         request.auth.uid == resource.data.receiverId);

      // Solo el remitente puede escribir mensajes
      allow write: if request.auth != null &&
        request.auth.uid == request.resource.data.senderId;
    }

    // --- PENDING NOTIFICATIONS ---
    match /pendingNotifications/{notificationId} {
      // Los usuarios autenticados pueden crear notificaciones pendientes
      allow create: if request.auth != null;
      
      // Solo Cloud Functions pueden leer/actualizar/eliminar
      // (request.auth == null significa que es una solicitud del servidor)
      allow read, update, delete: if request.auth == null;
    }

    // --- USER INTERACTIONS (Analytics) ---
    match /user_interactions/{interactionId} {
      // Solo el propietario puede escribir sus propias interacciones
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId;
      
      // Solo Cloud Functions pueden leer (para agregación)
      allow read: if request.auth == null;
      
      // No permitir actualizar o eliminar
      allow update, delete: if false;
    }

    // --- USER ANALYTICS (Aggregated) ---
    match /user_analytics/{userId} {
      // Solo Cloud Functions pueden leer/escribir estadísticas agregadas
      allow read, write: if request.auth == null;
    }

    // --- STORIES ---
    match /stories/{storyId} {
      // Helper function: verificar si el usuario participa en el match
      function isMatchParticipant(matchId) {
        return request.auth.uid in get(/databases/$(database)/documents/matches/$(matchId)).data.usersMatched;
      }
      
      // Lectura: permitir para:
      // 1. Stories globales (cualquiera puede verlas)
      // 2. Stories personales (cualquiera puede ver METADATOS para mostrar indicador)
      // 3. Stories de match donde el usuario es participante del match
      allow read: if request.auth != null && 
        (resource.data.get('isGlobal', false) == true ||
         resource.data.get('isPersonal', false) == true ||
         // Verificar si es participante del match (para stories de match)
         (resource.data.keys().hasAny(['matchId']) && 
          isMatchParticipant(resource.data.matchId)));
      
      // Crear story: usuario autenticado puede crear globales, personales o de match
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.senderId &&
        (
          // Story global: solo verificar que es el creador
          (request.resource.data.get('isGlobal', false) == true) ||
          // Story personal: solo verificar que es el creador
          (request.resource.data.get('isPersonal', false) == true) ||
          // Story de match: verificar que es participante del match
          (request.resource.data.keys().hasAny(['matchId']) && 
           isMatchParticipant(request.resource.data.matchId))
        );
      
      // Actualizar (marcar como visto): permitir solo si:
      // 1. Es una story global
      // 2. Es una story personal
      // 3. Es participante del match (para stories de match)
      allow update: if request.auth != null &&
        (resource.data.get('isGlobal', false) == true ||
         resource.data.get('isPersonal', false) == true ||
         (resource.data.keys().hasAny(['matchId']) && 
          isMatchParticipant(resource.data.matchId)));
      
      // Eliminar: solo el creador
      allow delete: if request.auth != null &&
        request.auth.uid == resource.data.senderId;
    }

    // --- SYSTEM STATS (for Cloud Functions) ---
    match /system_stats/{docId} {
      // Solo Cloud Functions pueden leer/escribir estadísticas del sistema
      allow read, write: if request.auth == null;
    }

    // --- DEFAULT ---
    match /{document=**} {
      allow read, write: if false; // Bloquea todo lo demás
    }
  }
}
